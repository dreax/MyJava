
- [Java 基础](#java---)
  * [JDK 和 JRE 有什么区别？](#JDK 和 JRE 有什么区别？)
  * [== 和 equals 的区别是什么？](#-----equals--------)
  * [两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？](#------hashcode-------equals-------true----)
  * [final 在 java 中有什么作用？](#final---java--------)
  * [java 中的 Math.round(-1.5) 等于多少？](#java----mathround--15-------)
  * [String 属于基础的数据类型吗？](#string------------)
  * [java 中操作字符串都有哪些类？它们之间有什么区别？](#java-----------------------)
  * [String str="i"与 String str=new String(“i”)一样吗？](#string-str--i---string-str-new-string--i------)
  * [如何将字符串反转？](#---------)
  * [String 类的常用方法都有那些？](#string------------)
  * [抽象类必须要有抽象方法吗？](#-------------)
  * [抽象类能使用 final 修饰吗？](#-------final-----)
  * [接口和抽象类有什么区别？](#------------)
  * [java 中 IO 流分为几种？](#java---io-------)
  * [BIO、NIO、AIO 有什么区别？](#bio-nio-aio-------)
  * [Files的常用方法都有哪些？](#files----------)
- [容器](#--)
  * [java 容器都有哪些？](#java--------)
  * [Collection 和 Collections 有什么区别？](#collection---collections-------)
  * [List、Set、Map 之间的区别是什么？](#list-set-map----------)
  * [HashMap 和 Hashtable 有什么区别？](#hashmap---hashtable-------)
  * [如何决定使用 HashMap 还是 TreeMap？](#-------hashmap----treemap-)
  * [说一下 HashMap 的实现原理？](#----hashmap-------)
  * [说一下 HashSet 的实现原理？](#----hashset-------)
  * [ArrayList 和 LinkedList 的区别是什么？](#arraylist---linkedlist--------)
  * [ArrayList 和 Vector 的区别是什么？](#arraylist---vector--------)
  * [Array 和 ArrayList 有何区别？](#array---arraylist------)
  * [在 Queue 中 poll()和 remove()有什么区别？](#--queue---poll----remove--------)
  * [哪些集合类是线程安全的？](#------------)
  * [迭代器 Iterator 是什么？](#----iterator-----)
  * [Iterator 怎么使用？有什么特点？](#iterator------------)
  * [Iterator 和 ListIterator 有什么区别？](#iterator---listiterator-------)
  * [怎么确保一个集合不能被修改？](#--------------)
- [多线程](#---)
  * [并行和并发有什么区别？](#-----------)
  * [线程和进程的区别？](#---------)
  * [守护线程是什么？](#--------)
  * [创建线程有哪几种方式？](#-----------)
  * [说一下 runnable 和 callable 有什么区别？](#----runnable---callable-------)
  * [线程有哪些状态？](#--------)
  * [sleep() 和 wait() 有什么区别？](#sleep-----wait---------)
  * [notify()和 notifyAll()有什么区别？](#notify----notifyall--------)
  * [线程的 run()和 start()有什么区别？](#----run----start--------)
  * [使用线程池的好处](#--------)
  * [创建线程池有哪几种方式？](#------------)
  * [线程池都有哪些状态？](#----------)
  * [线程池中 submit()和 execute()方法有什么区别？](#-----submit----execute----------)
  * [在 java 程序中怎么保证多线程的运行安全？](#--java-----------------)
  * [多线程锁的升级原理是什么？](#-------------)
  * [什么是死锁？](#------)
  * [怎么防止死锁？](#-------)
  * [ThreadLocal 是什么？有哪些使用场景？](#threadlocal-------------)
  * [说一下 synchronized 底层实现原理？](#----synchronized--------)
  * [synchronized 和 volatile 的区别是什么？](#synchronized---volatile--------)
  * [synchronized 和 Lock 有什么区别？](#synchronized---lock-------)
  * [synchronized 和 ReentrantLock 区别是什么？](#synchronized---reentrantlock-------)
  * [说一下 atomic 的原理？](#----atomic-----)
- [JVM](#jvm)
  * [说一下 jvm 的主要组成部分？及其作用？](#----jvm--------------)
  * [说一下 jvm 运行时数据区？](#----jvm--------)
  * [说一下堆栈的区别？](#---------)
  * [队列和栈是什么？有什么区别？](#--------------)
  * [什么是双亲委派模型？](#----------)
  * [说一下类加载的执行过程？](#------------)
  * [说一下Java对象的创建过程？](#---java--------)
  * [怎么判断对象是否可以被回收？](#--------------)
  * [java 中都有哪些引用类型？](#java-----------)
  * [说一下 jvm 有哪些垃圾回收算法？](#----jvm-----------)
  * [说一下 jvm 有哪些垃圾回收器？](#----jvm----------)
  * [详细介绍一下 CMS 垃圾回收器？](#-------cms-------)
  * [新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？](#----------------------------)
  * [简述分代垃圾回收器是怎么工作的？](#----------------)
  * [说一下 jvm 调优的工具？](#----jvm-------)
  * [常用的 jvm 调优的参数都有哪些？](#----jvm-----------)
- [MySql](#mysql)
  * [数据库的三范式是什么？](#-----------)
  * [如何获取当前数据库版本？](#------------)
  * [说一下 ACID 是什么？](#----acid-----)
  * [char 和 varchar 的区别是什么？](#char---varchar--------)
  * [float 和 double 的区别是什么？](#float---double--------)
  * [mysql 的内连接、左连接、右连接有什么区别？](#mysql-------------------)
  * [mysql 索引是怎么实现的？](#mysql----------)
  * [怎么验证 mysql 的索引是否满足需求？](#-----mysql-----------)
  * [说一下数据库的事务隔离？](#------------)
  * [说一下 mysql 常用的引擎？](#----mysql-------)
  * [说一下 mysql 的行锁和表锁？](#----mysql--------)
  * [说一下乐观锁和悲观锁？](#-----------)
  * [mysql 问题排查都有哪些手段？](#mysql------------)
  * [如何做 mysql 的性能优化？](#----mysql-------)
- [Spring/Spring MVC](#spring-spring-mvc)
  * [为什么要使用 spring？](#-------spring-)
  * [解释一下什么是 aop？](#--------aop-)
  * [解释一下什么是 ioc？](#--------ioc-)
  * [spring 有哪些主要模块？](#spring---------)
  * [spring 常用的注入方式有哪些？](#spring------------)
  * [spring 中的 bean 是线程安全的吗？](#spring----bean---------)
  * [spring 支持几种 bean 的作用域？](#spring------bean------)
  * [spring 自动装配 bean 有哪些方式？](#spring------bean-------)
  * [spring 事务实现方式有哪些？](#spring-----------)
  * [说一下 spring 的事务隔离？](#----spring-------)
  * [说一下 spring mvc 运行流程？](#----spring-mvc------)
  * [spring mvc 有哪些组件？](#spring-mvc-------)
  * [@RequestMapping 的作用是什么？](#-requestmapping--------)
  * [@Autowired 的作用是什么？](#-autowired--------)
  * [什么是 spring boot？](#----spring-boot-)
  * [为什么要用 spring boot？](#------spring-boot-)
  * [spring boot 核心配置文件是什么？](#spring-boot-----------)
  * [spring boot 配置文件有哪几种类型？它们有什么区别？](#spring-boot--------------------)
  * [spring boot 有哪些方式可以实现热部署？](#spring-boot--------------)
  * [什么是 spring cloud？](#----spring-cloud-)
  * [spring cloud 断路器的作用是什么？](#spring-cloud-----------)
  * [spring cloud 的核心组件有哪些？](#spring-cloud----------)
- [Mybatis](#mybatis)
  * [mybatis 中 #{}和 ${}的区别是什么？](#mybatis------------------)
  * [mybatis 有几种分页方式？](#mybatis---------)
  * [RowBounds 是一次性查询全部结果吗？为什么？](#rowbounds-----------------)
  * [mybatis 逻辑分页和物理分页的区别是什么？](#mybatis-----------------)
  * [mybatis 是否支持延迟加载？延迟加载的原理是什么？](#mybatis---------------------)
  * [说一下 mybatis 的一级缓存和二级缓存？](#----mybatis------------)
  * [mybatis 和 hibernate 的区别有哪些？](#mybatis---hibernate--------)
  * [mybatis 有哪些执行器（Executor）？](#mybatis--------executor--)
  * [mybatis 分页插件的实现原理是什么？](#mybatis--------------)
  * [mybatis 如何编写一个自定义插件？](#mybatis-------------)
- [Redis](#redis)
  * [redis 是什么？都有哪些使用场景？](#redis--------------)
  * [redis 有哪些功能？](#redis-------)
  * [redis 和 memecache 有什么区别？](#redis---memecache-------)
  * [redis 为什么是单线程的？](#redis----------)
  * [什么是缓存穿透？怎么解决？](#-------------)
  * [redis 支持的数据类型有哪些？](#redis------------)
  * [redis 支持的 java 客户端都有哪些？](#redis-----java---------)
  * [jedis 和 redisson 有哪些区别？](#jedis---redisson-------)
  * [怎么保证缓存和数据库数据的一致性？](#-----------------)
  * [redis 持久化有几种方式？](#redis----------)
  * [redis 怎么实现分布式锁？](#redis----------)
  * [redis 分布式锁有什么缺陷？](#redis-----------)
  * [redis 如何做内存优化？](#redis---------)
  * [redis 淘汰策略有哪些？](#redis---------)
  * [redis 常见的性能问题有哪些？该如何解决？](#redis------------------)
- [Zookeeper](#zookeeper)
- [Kafka](#kafka)
- [RabbitMQ](#rabbitmq)
- [反射](#--)
- [异常](#--)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>


## Java 基础
### JDK 和 JRE 有什么区别？

`JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。`

`JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。`

### == 和 equals 的区别是什么？
`== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型,比较的是值，引用数据类型==比较的是内存地址)。`

`equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：`
* 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
* 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

### 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

`hashCode() `的作用就是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`在散列表中才有用，在其它情况下没用。在散列表中 `hashCode()` 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

`hashCode（）与 equals（）的相关规定`
* 如果两个对象相等，则 hashcode 一定也是相同的
* 两个对象相等,对两个对象分别调用 equals 方法都返回 true
* 两个对象有相同的 hashcode 值，它们也不一定是相等的
* 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
* hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的* 两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

### final 在 java 中有什么作用？

`final 关键字主要用在三个地方：变量、方法、类。`
* 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
* 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。
* 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。

### java 中的 Math.round(-1.5) 等于多少？
答案=-1
* Math.ceil  向上取整
* Math.floor 向下取整
* Math.round +0.5之后 向下取整

### String 属于基础的数据类型吗？
属于引用类型
`基本类型：`
* 整型：byte，short，int,long
* 浮点型：float，double
* 字符型：char
* Boolean型：boolean

### java 中操作字符串都有哪些类？它们之间有什么区别？
* String ：线程安全，对象不可变的
* StringBuilder:线程不安全，对象可变
* StringBuffer:线程安全的，对象可变

`对于三者使用的总结：`
* 操作少量的数据: 适用 String
* 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
* 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

### String str="i"与 String str=new String(“i”)一样吗？

`不一样，因为内存的分配方式不一样。String str="i"的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。`

### 如何将字符串反转？
`利用 StringBuffer 或 StringBuilder 的 reverse 方法`

### String 类的常用方法都有那些？
* indexOf() 返回指定字符得索引
* charAt() 返回指定索引处得字符
* repalce() 字符串替换
* trim() 去除字符串两端的空白
* split() 分割字符串 返回分割后的字符串数组
* getBytes() 返回字符串的byte类型数组
* length() 返回字符串的长度
* toLowerCase() 字符串转小写
* toUpperCase() 字符串转大写
* substring() 截取字符串
* equals() 字符串比较

### 抽象类必须要有抽象方法吗？
`不必须`
* 抽象类必须有关键字abstract来修饰。
* 抽象类可以不含有抽象方法
* 如果一个类包含抽象方法，则该类必须是抽象类

12.普通类和抽象类有哪些区别？
* 抽象类不能被实例化
* 抽象类可以有抽象方法，抽象方法只需申明，无需实现
* 含有抽象方法的类必须申明为抽象类
* 抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类
* 抽象方法不能被声明为静态
* 抽象方法不能用 private 修饰
* 抽象方法不能用 final 修饰

### 抽象类能使用 final 修饰吗？
`不能 因为抽象类必须要被继承`

### 接口和抽象类有什么区别？
* 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
* 抽象类要被子类继承，接口要被类实现。
* 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
* 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
* 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
* 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
* 抽象类里可以没有抽象方法
* 如果一个类里有抽象方法，那么这个类只能是抽象类
* 抽象方法要被实现，所以不能是静态的，也不能是私有的。
* 接口可继承接口，并可多继承接口，但类只能单根继承。

### java 中 IO 流分为几种？
* 按照流的流向分，可以分为输入流和输出流；
* 按照操作单元划分，可以划分为字节流和字符流；
* 按照流的角色划分为节点流和处理流。

`既然有了字节流,为什么还要有字符流?`
问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？
回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。
### BIO、NIO、AIO 有什么区别？
* BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
* NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
* AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。

### Files的常用方法都有哪些？
* Files.exists() 检测文件路径是否存在
* Files.createFile()创建文件
* Files.createDirectory()创建文件夹
* Files.delete() 删除文件或者目录
* Files.copy() 复制文件
* Files.move() 移动文件
* Files.size（）查看文件个数
* Files.read() 读取文件
* Files.write()写入文件


## 容器

### java 容器都有哪些？
![容器](./collection.png)
### Collection 和 Collections 有什么区别？
* Collection 是集合的接口，其继承类又List Set
* Collections 是集合的工具类，定义了许多操作集合的静态方法。是帮助类。
### List、Set、Map 之间的区别是什么？
* List的元素以线性方式存储，可以存放重复对象
* Set中的对象不按特定(HashCode)的方式排序，并且没有重复对象
* Map是一种把键对象和值对象映射的集合，它的每一个元素都包含一个键对象和值对象

### HashMap 和 Hashtable 有什么区别？
`HashMap线程不安全，Hashtable线程安全`
### 如何决定使用 HashMap 还是 TreeMap？
`如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。`
### 说一下 HashMap 的实现原理？
JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。（当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间）HashMap 通过 key 的 hashCode 经过Hash方法处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。

性质1. 节点是红色或黑色。 [3] 
性质2. 根节点是黑色。 [3] 
性质3.所有叶子都是黑色。（叶子是NUIL节点） [3] 
性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
性质5.. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点


### 说一下 HashSet 的实现原理？
HashSet 底层就是基于 HashMap 实现的

HashSet如何检查重复
当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。

### ArrayList 和 LinkedList 的区别是什么？
*  底层数据结构：Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构
* 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)
* 插入和删除是否受元素位置的影响： ①ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响，LinkedList 采用链表存储，所以对于add方法的插入，删除元素时间复杂度不受元素位置的影响

### ArrayList 和 Vector 的区别是什么？
`线程不安全和线程安全`
### Array 和 ArrayList 有何区别？
Array 必须初始化大小
Array只能放类型相同的对象，

### 在 Queue 中 poll()和 remove()有什么区别？
如果队列为空的时候，remove() ，则会抛出异常
poll（）只会返回null

### 哪些集合类是线程安全的？
* Vector：就比Arraylist多了个同步化机制（线程安全）。
* Hashtable：就比Hashmap多了个线程安全。
* ConcurrentHashMap:是一种高效但是线程安全的集合。
* Stack：栈，也是线程安全的，继承于Vector。

### 迭代器 Iterator 是什么？
`它可以遍历并选择序列中的对象`
### Iterator 怎么使用？有什么特点？
next()
hasNext()
remove()
Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。
### Iterator 和 ListIterator 有什么区别？
1.Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。
2.Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。
3.ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。
4.ListIterator 可以使用set()方法替换它访问过的最后一个元素.
5.ListIterator 可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.
### 怎么确保一个集合不能被修改？
可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合

## 多线程
### 并行和并发有什么区别？
* 并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
* 并行： 单位时间内，多个任务同时执行。
### 线程和进程的区别？
线程是最小的执行单位，一个进程可以产生多个线程，切换线程比切换进程代价更小。
进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。
### 守护线程是什么？
守护线程是为其他线程服务，当其他线程执行完线程后，守护线程才退出
### 创建线程有哪几种方式？
1）继承Thread类创建线程

2）实现Runnable接口创建线程

3）使用Callable和Future创建线程

4）使用线程池例如用Executor框架
### 说一下 runnable 和 callable 有什么区别？
* Runnable执行方法是run(),Callable是call()
* 实现Runnable接口的任务线程无返回值；实现Callable接口的任务线程能返回执行结果
* call方法可以抛出异常，run方法若有异常只能在内部消化

### 线程有哪些状态？
* 线程状态有 5 种，新建，就绪，运行，阻塞，死亡

### sleep() 和 wait() 有什么区别？

* 两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。
* 两者都可以暂停线程的执行。
* Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
* wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。
* wait 作用在对象上，sleep作用在Thread上面
### notify()和 notifyAll()有什么区别？
* 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
* 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争
* 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。


### 线程的 run()和 start()有什么区别？
new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

### 使用线程池的好处
* 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
* 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
* 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 创建线程池有哪几种方式？
1.使用构造函数 new TreadPoolExecutor
2.通过Executor 框架的工具类Executors来实现
* newCachedThreadPool（），它是用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置时间超过60秒，则被终止并移除缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。
* newFixedThreadPool（int nThreads），重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动线程数目，将在工作队列中等待空闲线程出现；如果工作线程退出，将会有新的工作线程被创建，以补足指定数目nThreads。
* newSingleThreadExecutor()，它的特点在于工作线程数目限制为1，操作一个无界的工作队列，所以它保证了所有的任务都是被顺序执行，最多会有一个任务处于活动状态，并且不予许使用者改动线程池实例，因此可以避免改变线程数目。
* newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。
* newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。

### 线程池都有哪些状态？
1.RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。
2.SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。调用线程池的shutdown()方法时，线程池由RUNNING -> SHUTDOWN。
3.STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN ) -> STOP。
4.TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。因为terminated()在ThreadPoolExecutor类中是空的，所以用户想在线程池变为TIDYING时进行相应的处理；可以通过重载terminated()函数来实现。 
当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。
5.TERMINATED：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

### 线程池中 submit()和 execute()方法有什么区别？
* execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
* submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

### 在 java 程序中怎么保证多线程的运行安全？
1、使用synchronied关键字，可以用于代码块，方法（静态方法，同步锁是当前字节码对象；实例方法，同步锁是实例对象）

2、使用volatile 关键字，防止指令重排，被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量

3、lock锁机制

4、使用线程安全的类，比如Vector、HashTable、StringBuffer

线程安全在三个方面体现：

    原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；

    可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；

    有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）
### 多线程锁的升级原理是什么？
`锁的级别从低到高：`
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
`锁分级别原因：`
没有优化以前，sychronized是重量级锁（悲观锁），使用 wait 和 notify、notifyAll 来切换线程状态非常消耗系统资源；线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以 JVM 对 sychronized 关键字进行了优化，把锁分为 无锁、偏向锁、轻量级锁、重量级锁 状态。


* 无锁：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直到修改成功。

* 偏向锁：对象的代码一直被同一线程执行，不存在多个线程竞争，该线程在后续的执行中自动获取锁，降低获取锁带来的性能开销。偏向锁，指的就是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。
偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁；
如果线程处于活动状态，升级为轻量级锁的状态。

* 轻量级锁：轻量级锁是指当锁是偏向锁的时候，被第二个线程 B 所访问，此时偏向锁就会升级为轻量级锁，线程 B 会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。
当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁；当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁。

* 重量级锁：指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。
重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。

### 什么是死锁？
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。
产生死锁必须具备以下四个条件：
* 互斥条件：该资源任意一个时刻只由一个线程占用。
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
* 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
* 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
### 怎么防止死锁？
* 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
* 破坏请求与保持条件 ：一次性申请所有的资源。
* 破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
* 破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。
### ThreadLocal 是什么？有哪些使用场景？
通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。
如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

### 说一下 synchronized 底层实现原理？
synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

### synchronized 和 volatile 的区别是什么？
* volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。
* 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞
volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
* volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。
### synchronized 和 Lock 有什么区别？
### synchronized 和 ReentrantLock 区别是什么？

① 两者都是可重入锁

两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。

③ ReentrantLock 比 synchronized 增加了一些高级功能

相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）

ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。
synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。
如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。

④ 性能已不是选择标准

### 说一下 atomic 的原理？

主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。

## JVM

### 说一下 jvm 的主要组成部分？及其作用？

* 类加载器：加载类文件到内存。Class loader只管加载，只要符合文件结构就加载，至于能否运行，它不负责，那是有Exectution Engine 负责的。
* 执行引擎:也叫解释器，负责解释命令，交由操作系统执行。
* 本地接口:本地接口的作用是融合不同的语言为java所用。
* 运行数据区：运行数据区是jvm的重点，我们所有所写的程序都被加载到这里，之后才开始运行。


### 说一下 jvm 运行时数据区？
* 运行数据区：运行数据区是jvm的重点，我们所有所写的程序都被加载到这里，之后才开始运行。
    * 栈:也叫栈内存，是java程序的运行区，是在线程创建时创建，它的生命周期跟随线程的生命周期，线程结束栈内存释放；对于栈来说不存在垃圾回收的问题，只要线程一结束，该栈就结束。栈中的数据以栈帧的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的集合，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。
    * 堆内存：Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。
    * 方法区：方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。
    * 程序计数器：程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。
    另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
    从上面的介绍中我们知道程序计数器主要有两个作用：
        1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
        2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
### 说一下堆栈的区别？


* 各司其职：最主要的区别就是栈内存用来存储局部变量和方法调用。
而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。

* 独有还是共享：栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。

* 异常错误：如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。
而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。

* 空间大小：栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。

### 队列和栈是什么？有什么区别？

1.队列(Queue)：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表
2.栈(Stack)：是限定只能在表的一端进行插入和删除操作的线性表
3.队列先进先出(FIFO)，栈先进后出(FILO)

### 什么是双亲委派模型？
如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

双亲委派模式优势
采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

### 说一下类加载的执行过程？
1、首先加载要创建对象的类及其直接与间接父类。
2、在类被加载的同时会将静态成员度进行加载，主要包括静知态成员变量的初始化，静态语句块的执行，在加载道时按代码的先后顺序进行。
3、需要的类加载完成后，开始创建对象，首先会加载非静态的成员，主要包括内非静态成员变量的初始化，非静态语句块的执行，在加载时按代码的先后顺序容进行。
4、最后执行构造器，构造器执行完毕，对象生成。
### 说一下Java对象的创建过程？
①类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
②分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
③初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
④设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
⑤执行 init 方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init> `方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 怎么判断对象是否可以被回收？
`引用计数法`
给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

`可达性分析算法`
这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。
### java 中都有哪些引用类型？
* 强引用：Java中默认声明的就是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
* 软引用：如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
* 弱引用：弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
* 虚引用：虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
### 说一下 jvm 有哪些垃圾回收算法？
* 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：效率问题，空间问题（标记清除后会产生大量不连续的碎片）
* 复制算法：它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
* 标记-整理算法：根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
* 分代收集算法:当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
### 说一下 jvm 有哪些垃圾回收器？
* CMS收集器:![CMS](./CMS.png)
* G1收集器:![G1](./G1.png)
* Serial收集器:Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。
* ParNew收集器:ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。
* Parallel Scavenge收集器:新生代采用复制算法，老年代采用标记-整理算法
* Serial Old收集器:
* Parallel Old收集器:
### 详细介绍一下 CMS 垃圾回收器？
![CMS](./CMS.png)
### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
新生代回收器：Serial、ParNew、Parallel Scavenge
老年代回收器：Serial Old、Parallel Old、CMS
整堆回收器：G1
新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。

### 简述分代垃圾回收器是怎么工作的？
分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，
它的执行流程如下：
把 Eden + From Survivor 存活的对象放入 To Survivor 区；
清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。
老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。
以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。
### 说一下 jvm 调优的工具？
* jstat：统计信息监视工具，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据 -gc -gcutil
* jmap：Java内存印象工具,生成heap dump文件 -dump -heap -histo
* jstack：Java堆栈跟踪工具,来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 
### 常用的 jvm 调优的参数都有哪些？
-Xms2g：初始化推大小为 2g；
-Xmx2g：堆最大内存为 2g；
-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
-XX:+PrintGC：开启打印 gc 信息；
-XX:+PrintGCDetails：打印 gc 详细信息



## MySql

### 数据库的三范式是什么？
1、第一范式：
当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。
2、第二范式：
如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。
3、第三范式：
设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF。

### 如何获取当前数据库版本？
select version();
### 说一下 ACID 是什么？
原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
### char 和 varchar 的区别是什么？
1.char类型的长度是固定的，varchar的长度是可变的。

### float 和 double 的区别是什么？
double 和 float 的区别是double精度抄高，有效数字16位，float精度7位
### mysql 的内连接、左连接、右连接有什么区别？
1.内连接只显示两表中有关联的数据
2.左连接显示左表所有数据，右表没有对应的数据用NULL补齐，多了的数据删除
3.右连接显示右表所有数据，左表没有对应的数据用NULL对齐，多了的数据删除
### mysql 索引是怎么实现的？
MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。

MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

### 怎么验证 mysql 的索引是否满足需求？
根据查询需求决定配置的索引类型，确定后，使用 explain 来查看执行计划。explain可以检查你的sql索引命中情况，实际上线后，最好配合监控来看下接口的RT
### 说一下数据库的事务隔离？

READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
### 说一下 mysql 常用的引擎？
MyISAM和InnoDB区别
MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。

大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。

两者对比：
是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
是否支持外键： MyISAM不支持，而InnoDB支持。
是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一
### 说一下 mysql 的行锁和表锁？
表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

### 说一下乐观锁和悲观锁？
悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它自己拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。
### mysql 问题排查都有哪些手段？
使用 show processlist 命令查看当前所有连接信息。
使用 explain 命令查询 SQL 语句执行计划。
开启慢查询日志，查看慢查询的 SQL。
### 如何做 mysql 的性能优化？
1. 所有表必须使用 Innodb 存储引擎
2. 数据库和表的字符集统一使用 UTF8
3. 谨慎使用 MySQL 分区表






## Spring/Spring MVC

### 为什么要使用 spring？
我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。
### 解释一下什么是 aop？
AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理.
使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。
### 解释一下什么是 ioc？
IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spring 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。
将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
### spring 有哪些主要模块？
Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。
Spring Aspects ： 该模块为与AspectJ的集成提供支持。
Spring AOP ：提供了面向切面的编程实现。
Spring JDBC : Java数据库连接。
Spring JMS ：Java消息服务。
Spring ORM : 用于支持Hibernate等ORM工具。
Spring Web : 为创建Web应用程序提供支持。
Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。

### spring 常用的注入方式有哪些？
构造方法注入，setter注入，基于注解的注入


基于注解：
@Component：可以用于注册所有bean
@Repository：主要用于注册dao层的bean
@Controller：主要用于注册控制层的bean
@Service：主要用于注册服务层的bean
### spring 中的 bean 是线程安全的吗？
大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。
常见的有两种解决办法：
在Bean对象中尽量避免定义可变的成员变量（不太现实）。
在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。
### spring 支持几种 bean 的作用域？
singleton：单例模式，在整个Spring IoC容器中，使用 singleton 定义的 bean 只有一个实例
prototype：原型模式，每次通过容器的getbean方法获取 prototype 定义的 bean 时，都产生一个新的 bean 实例

只有在 Web 应用中使用Spring时，request、session、global-session 作用域才有效
request：对于每次 HTTP 请求，使用 request 定义的 bean 都将产生一个新实例，即每次 HTTP 请求将会产生不同的 bean 实例。
session：同一个 Session 共享一个 bean 实例。
global-session：同 session 作用域不同的是，所有的Session共享一个Bean实例

### spring 自动装配 bean 有哪些方式？

no：不进行自动装配，手动设置Bean的依赖关系。
byName：根据Bean的名字进行自动装配。
byType：根据Bean的类型进行自动装配。
constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。
### spring 事务实现方式有哪些？
Spring 管理事务的方式有几种？
编程式事务，在代码中硬编码。(不推荐使用)
声明式事务，在配置文件中配置（推荐使用）
声明式事务又分为两种：

基于XML的声明式事务
基于注解的声明式事务

### 说一下 spring 的事务隔离？
如果不考虑隔离性引发安全性问题: 
脏读 :一个事务读到了另一个事务的未提交的数据 
不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致. 
虚幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.
解决读问题: 设置事务隔离级别（5种） 
DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别. 
未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生 
已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生 
可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生. 
串行化的 （serializable） :避免以上所有读问题. 
Mysql 默认:可重复读 
Oracle 默认:读已提交

### 说一下 spring mvc 运行流程？
客户端（浏览器）发送请求，直接请求到 DispatcherServlet。
DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。
解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。
HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。
处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。
ViewResolver 会根据逻辑 View 查找实际的 View。
DispaterServlet 把返回的 Model 传给 View（视图渲染）。
把 View 返回给请求者（浏览器）

### spring mvc 有哪些组件？
前端控制器（DispatcherServlet） 
处理器映射器（HandlerMapping） 
处理器适配器（HandlerAdapter） 
拦截器（HandlerInterceptor）
语言环境处理器（LocaleResolver）
主题解析器（ThemeResolver）
视图解析器（ViewResolver） 
文件上传处理器（MultipartResolver）
异常处理器（HandlerExceptionResolver） 
数据转换（DataBinder）
消息转换器（HttpMessageConverter）
请求转视图翻译器（RequestToViewNameTranslator）
页面跳转参数管理器（FlashMapManager）
处理程序执行链（HandlerExecutionChain） 
### @RequestMapping 的作用是什么？
@RequestMapping是一个用来处理请求地址映射的注解，可用于类或者方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
### @Autowired 的作用是什么？
Autowired 是一个注释，它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作
### 什么是 spring boot？
springboot就是Spring开源框架下的子项目，是Spring的一站式解决方案，主要是简化了spring的使用难度，降低了对配置文件的要求，使得开发人员能够更容易得上手
### 为什么要用 spring boot？
简化了Spring配置文件，
没有代码和XML文件的生成
内置TomCat
能够独立运行
简化监控
### spring boot 核心配置文件是什么？
SpringBoot的核心配置文件有application和bootstarp配置文件。

### spring boot 配置文件有哪几种类型？它们有什么区别？

application文件主要用于Springboot自动化配置文件。
bootstarp文件主要有以下几种用途：

使用Spring Cloud Config注册中心时 需要在bootStarp配置文件中添加链接到配置中心的配置属性来加载外部配置中心的配置信息。
一些固定的不能被覆盖的属性
一些加密/解密的场景
都有什么格式？
.properties 和 .yml
.yml采取的是缩进的格式 不支持@PeopertySource注解导入配置
### spring boot 有哪些方式可以实现热部署？
spring-boot-devtools
### 什么是 spring cloud？
Spring Cloud是一个微服务框架,Spring Cloud提供的全套的分布式系统解决方案。 
### spring cloud 断路器的作用是什么？
在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。
### spring cloud 的核心组件有哪些？
服务发现——Netflix Eureka

客服端负载均衡——Netflix Ribbon

断路器——Netflix Hystrix

服务网关——Netflix Zuul

分布式配置——Spring Cloud Config

## Mybatis

### mybatis 中 #{}和 ${}的区别是什么？
2、#{} 和 ${} 的区别
（1）
1）#{} 为参数占位符 ?，即sql 预编译

2）${} 为字符串替换，即 sql 拼接
（3）
1）#{} 的变量替换是在DBMS 中

2）${} 的变量替换是在 DBMS 外
（4）
1）变量替换后，#{} 对应的变量自动加上单引号 ''

2）变量替换后，${} 对应的变量不会加上单引号 ''

（5）
1）#{} 能防止sql 注入

2）${} 不能防止sql 注入

### mybatis 有几种分页方式？
### RowBounds 是一次性查询全部结果吗？为什么？
### mybatis 逻辑分页和物理分页的区别是什么？
### mybatis 是否支持延迟加载？延迟加载的原理是什么？
### 说一下 mybatis 的一级缓存和二级缓存？
### mybatis 和 hibernate 的区别有哪些？
### mybatis 有哪些执行器（Executor）？
### mybatis 分页插件的实现原理是什么？
### mybatis 如何编写一个自定义插件？

## Redis

### redis 是什么？都有哪些使用场景？
### redis 有哪些功能？
### redis 和 memecache 有什么区别？
对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！

redis支持更丰富的数据类型（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。
Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。
集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.
Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。

### redis 为什么是单线程的？
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

多个 socket
IO 多路复用程序
文件事件分派器
事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。
### 什么是缓存穿透？怎么解决？
1.参数校验
2.缓存无效的key
3.布隆过滤器
### redis 支持的数据类型有哪些？
String 
hash
set 
list
### redis 支持的 java 客户端都有哪些？
Redisson,Jedis
### jedis 和 redisson 有哪些区别？
jedis：提供了比较全面的 Redis 命令的支持。

Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。

### 怎么保证缓存和数据库数据的一致性？
(1)读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应
(2)更新的时候，先删除缓存，然后再更新数据库
### redis 持久化有几种方式？
快照和文件追加
### redis 怎么实现分布式锁？
SETNX key val
当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0

获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。
获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。
### redis 分布式锁有什么缺陷？
### redis 如何做内存优化？
### redis 淘汰策略有哪些？
### redis 常见的性能问题有哪些？该如何解决？



## Zookeeper

157.zookeeper 是什么？

158.zookeeper 都有哪些功能？

159.zookeeper 有几种部署模式？

160.zookeeper 怎么保证主从节点的状态同步？

161.集群中为什么要有主节点？

162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

163.说一下 zookeeper 的通知机制？




## Kafka

152.kafka 可以脱离 zookeeper 单独使用吗？为什么？

153.kafka 有几种数据保留的策略？

154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？

155.什么情况会导致 kafka 运行变慢？

156.使用 kafka 集群需要注意什么？





## RabbitMQ

135.rabbitmq 的使用场景有哪些？

136.rabbitmq 有哪些重要的角色？

137.rabbitmq 有哪些重要的组件？

138.rabbitmq 中 vhost 的作用是什么？

139.rabbitmq 的消息是怎么发送的？

140.rabbitmq 怎么保证消息的稳定性？

141.rabbitmq 怎么避免消息丢失？

142.要保证消息持久化成功的条件有哪些？

143.rabbitmq 持久化有什么缺点？

144.rabbitmq 有几种广播类型？

145.rabbitmq 怎么实现延迟消息队列？

146.rabbitmq 集群有什么用？

147.rabbitmq 节点的类型有哪些？

148.rabbitmq 集群搭建需要注意哪些问题？

149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？

150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？

151.rabbitmq 对集群节点停止顺序有要求吗？




## 反射

57.什么是反射？

58.什么是 java 序列化？什么情况下需要序列化？

59.动态代理是什么？有哪些应用？

60.怎么实现动态代理？

五、对象拷贝

61.为什么要使用克隆？

62.如何实现对象克隆？

63.深拷贝和浅拷贝区别是什么？

六、Java Web

64.jsp 和 servlet 有什么区别？

65.jsp 有哪些内置对象？作用分别是什么？

66.说一下 jsp 的 4 种作用域？

67.session 和 cookie 有什么区别？

68.说一下 session 的工作原理？

69.如果客户端禁止 cookie 能实现 session 还能用吗？

70.spring mvc 和 struts 的区别是什么？

71.如何避免 sql 注入？

72.什么是 XSS 攻击，如何避免？

73.什么是 CSRF 攻击，如何避免？

## 异常

74.throw 和 throws 的区别？

75.final、finally、finalize 有什么区别？

76.try-catch-finally 中哪个部分可以省略？

77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

78.常见的异常类有哪些？

